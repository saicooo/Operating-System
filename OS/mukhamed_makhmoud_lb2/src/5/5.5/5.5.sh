#!/bin/bash
# =========================== НАЗНАЧЕНИЕ ===========================
# Исследование планирования процессов в Linux с разными политиками планирования:
#
# 1. Изучение влияния различных политик планирования (SCHED_FIFO, SCHED_RR, 
#    SCHED_OTHER) на порядок выполнения процессов с одинаковыми приоритетами
# 2. Анализ конкуренции между процессами с разными политиками планирования
# 3. Исследование приоритетности политик планирования относительно друг друга
# 4. Проверка гипотезы о существовании иерархии между различными политиками
#    планирования независимо от числовых значений приоритетов процессов
#
# Скрипт демонстрирует, что политики планирования имеют приоритет над 
# числовыми значениями приоритетов: SCHED_FIFO и SCHED_RR (политики реального
# времени) всегда приоритетнее SCHED_OTHER (стандартная политика).
# ==================================================================
# 
# ============================ КОМАНДЫ =============================
# Скрипт выполняет следующие действия:
# 1. Компилирует исходные файлы prog-sched-fifo.c, prog-sched-rr.c и 
#    prog-sched-other.c
# 2. Запускает процессы с разными политиками планирования (FIFO, RR, OTHER)
#    с одинаковыми приоритетами в трёх разных порядках:
#    - fifo, rr, other
#    - other, rr, fifo
#    - rr, other, fifo
# 3. Использует taskset -c 0 для привязки всех процессов к одному ядру CPU,
#    чтобы обеспечить конкуренцию между ними
# 4. Демонстрирует, что SCHED_FIFO никогда не прерывается для SCHED_OTHER,
#    а SCHED_RR может временно уступать процессорное время SCHED_OTHER 
#    в моменты исчерпания своего временного кванта
# 5. Очищает скомпилированные файлы после завершения работы
#
# Вывод: Политика планирования действительно имеет более высокий приоритет, 
# чем числовое значение приоритета. Политики реального времени (FIFO, RR) 
# всегда приоритетнее SCHED_OTHER. При этом SCHED_FIFO является неквантованной
# политикой (процесс выполняется непрерывно), а SCHED_RR - квантованной 
# (процесс получает ограниченный квант времени), что объясняет различия
# в их поведении при конкуренции между собой и с SCHED_OTHER.
# ==================================================================
# 

DIRECTORY="5/5.5"

SRC_FILES=("prog-sched-fifo.c" "prog-sched-rr.c" "prog-sched-other.c")
EXEC=("prog-sched-fifo" "prog-sched-rr" "prog-sched-other")
PRIORITIES=("1" "1" "1")

compilate_files() {
    local -n src_files=$1
    local -n obj_files=$2

    local count=${#src_files[@]}
    for ((i=0; i<"$count"; i++)); do
        gcc "${src_files[$i]}" -o "${obj_files[$i]}"
    done
}

cd "$DIRECTORY"

compilate_files SRC_FILES EXEC

echo -e "\n===== Запуск процессов с разной политикой с одинаковым приоритетом =====\n"
echo -e  "\n--- Запуск в порядке: fifo, rr, other ---\n"
for ((i=0; i < ${#EXEC[@]}; i++)); do
    echo "Запуск процесса: "${EXEC[$i]}""
    taskset -c 0 ./"${EXEC[$i]}" "${PRIORITIES[$i]}" &
done

# Ожидаем завершения всех фоновых процессов, запущенных в текущем сеансе оболочки
wait

echo -e  "\n--- Запуск в порядке: other, rr, fifo ---\n"
for ((i=${#EXEC[@]}-1; i > -1; i--)); do
    echo "Запуск процесса: "${EXEC[$i]}""
    taskset -c 0 ./"${EXEC[$i]}" "${PRIORITIES[$i]}" &
done

# Ожидаем завершения всех фоновых процессов, запущенных в текущем сеансе оболочки
wait

EXEC=("prog-sched-rr" "prog-sched-other" "prog-sched-fifo")
echo -e  "\n--- Запуск в порядке: rr, other, fifo ---\n"
for ((i=0; i < ${#EXEC[@]}; i++)); do
    echo "Запуск процесса: "${EXEC[$i]}""
    taskset -c 0 ./"${EXEC[$i]}" "${PRIORITIES[$i]}" &
done

# Ожидаем завершения всех фоновых процессов, запущенных в текущем сеансе оболочки
wait

rm "${EXEC[@]}"