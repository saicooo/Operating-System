#!/bin/bash
# =========================== НАЗНАЧЕНИЕ ===========================
# Исследование планирования процессов в Linux с использованием политики RR:
#
# 1. Изучение порядка предоставления процессора при одинаковых приоритетах
#    для процессов с политикой RR (Round Robin)
# 2. Анализ влияния разных значений приоритетов на очередность исполнения 
#    процессов при политике RR
# 3. Демонстрация работы функции sched_yield() для изменения порядка очереди
#    в процедуре планирования RR
# 4. Определение величины кванта времени для политики планирования RR
#
# Скрипт наглядно показывает работу планировщика процессов в Linux
# при использовании политики планирования реального времени RR (Round Robin).
# ==================================================================
# 
# ============================ КОМАНДЫ =============================
# Скрипт выполняет следующие действия:
# 1. Компилирует исходные файлы prog1.c, prog2.c, yield.c и quant.c
# 2. Запускает два процесса с одинаковым приоритетом (35) и политикой RR
#    на одном процессорном ядре (taskset -c 0) для анализа очередности
#    выполнения
# 3. Запускает те же процессы с разными приоритетами (70 и 10) для 
#    демонстрации влияния приоритета на порядок планирования
# 4. Запускает процессы с использованием функции sched_yield() для 
#    демонстрации изменения порядка очереди в RR-планировании
# 5. Определяет величину кванта времени для политики планирования RR
# 6. Очищает скомпилированные файлы после завершения работы
#
# Вывод: Политика планирования SCHED_RR использует алгоритм циклического 
# планирования с вытеснением на основе приоритетов и временных квантов.
# При одинаковых приоритетах процессы выполняются циклически, каждый получает 
# фиксированный квант времени (100 мс), после чего CPU переключается на следующий процесс.
# При разных приоритетах процессы с более высоким приоритетом получают CPU первыми,
# а процессы с низким приоритетом выполняются только когда нет готовых процессов 
# с более высоким приоритетом.
# Функция sched_yield() позволяет процессу добровольно отказаться от оставшейся части 
# своего временного кванта, перейдя в конец очереди процессов с тем же приоритетом.
# Диапазон приоритетов для SCHED_RR составляет от 1 до 99, как и для SCHED_FIFO.
# ==================================================================
#

DIRECTORY="5/5.4"

SRC_FILES=("prog1.c" "prog2.c" "prog3.c" "prog4.c" "yield.c" "quant.c")
EXEC=("prog1" "prog2" "prog3" "prog4" "yield" "quant")
PRIORITIES=("35" "35" "35" "35" "35")

compilate_files() {
    local -n src_files=$1
    local -n obj_files=$2

    local count=${#src_files[@]}
    for ((i=0; i<"$count"; i++)); do
        gcc "${src_files[$i]}" -o "${obj_files[$i]}"
    done
}

cd "$DIRECTORY"

compilate_files SRC_FILES EXEC

echo -e "\n===== Запуск процессов с политикой RR с одинаковым приоритетом =====\n"
for ((i=0; i < ${#EXEC[@]}-2; i++)); do
    echo "Запуск процесса: "${EXEC[$i]}", приоритет: "${PRIORITIES[$i]}""
    taskset -c 0 ./"${EXEC[$i]}" "${PRIORITIES[$i]}" &
done

# Ожидаем завершения всех фоновых процессов, запущенных в текущем сеансе оболочки
wait

echo
echo -e "\n===== Запуск процессов с политикой RR с разным приоритетом =====\n"
PRIORITIES=("70" "10" "35" "35")
for ((i=0; i < ${#EXEC[@]}-2; i++)); do
    echo "Запуск процесса: "${EXEC[$i]}", приоритет: "${PRIORITIES[$i]}""
    taskset -c 0 ./"${EXEC[$i]}" "${PRIORITIES[$i]}" &
done

# Ожидаем завершения всех фоновых процессов, запущенных в текущем сеансе оболочки
wait

echo
echo -e "\n===== Запуск процессов с политикой RR и sched_yield =====\n"
PRIORITIES=("35" "35" "35" "35" "35")
for ((i=0; i < ${#EXEC[@]}-1; i++)); do
    echo "Запуск процесса: "${EXEC[$i]}", приоритет: "${PRIORITIES[$i]}""
    taskset -c 0 ./"${EXEC[$i]}" "${PRIORITIES[$i]}" &
done

# Ожидаем завершения всех фоновых процессов, запущенных в текущем сеансе оболочки
wait

echo
echo -e "\n==== Вычисление величины кванта для политики RR ====\n"

./"${EXEC[${#EXEC[@]}-1]}" "35"

rm "${EXEC[@]}"