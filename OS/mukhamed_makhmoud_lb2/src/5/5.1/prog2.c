/*
 * ======================================================================
 * Лабораторная работа 2, задание 5.1 (планирование процессов)
 * ======================================================================
 *
 * ЗАДАЧА:
 * Определение политики планирования и приоритета, установленных по
 * умолчанию, для процессов, запускаемых пользователем из shell. Анализ
 * очередности исполнения процессов при различных приоритетах и политиках.
 *
 * ЧТО ДЕЛАЕТ ПРОГРАММА:
 * Программа prog2 является тестовой программой, которая выводит
 * информацию о себе. Используется для анализа очередности
 * исполнения процессов при их одновременном запуске с разными приоритетами
 * и политиками планирования. Выводит PID, PPID и текущую политику планирования.
 *
 * КОМПИЛЯЦИЯ И ЗАПУСК:
 * $ gcc prog2.c -o prog2
 * $ ./prog2
 * $ taskset -c 0 ./prog2 # для привязки к конкретному ядру
 *
 * РЕЗУЛЬТАТЫ И ВЫВОДЫ:
 * - При запуске с одинаковым приоритетом (0) получает примерно равную
 *   долю процессорного времени, чередуясь с другими процессами.
 * - При запуске с приоритетом nice=5 (пониженным) получает меньше времени,
 *   чем процессы с отрицательными значениями nice, но больше чем процессы
 *   с более высоким nice.
 * - Занимает промежуточное положение в иерархии распределения времени
 *   при запуске с разными приоритетами.
 * - Демонстрирует, что вытесняющий алгоритм планирования регулярно 
 *   переключается между процессами даже при большой вычислительной нагрузке.
 */

#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/resource.h>
#include <unistd.h>

// Функция для получения строкового представления политики планирования
char *get_policy_name(int policy) {
    char *policy_name;

    switch (policy) {
        case SCHED_FIFO:
            policy_name = "SCHED_FIFO";
            break;
        case SCHED_RR:
            policy_name = "SCHED_RR";
            break;
        case SCHED_OTHER:
            policy_name = "SCHED_OTHER";
            break;
        default:
            policy_name = "UNKNOWN";
            break;
    }

    return policy_name;
}

int main(int argc, char *argv[]) {

    if (argc < 2) {
        fprintf(stderr, "Ошибка argc: необходимо задать приоритет\n");
        exit(EXIT_FAILURE);
    }

    int priority = atoi(argv[1]);

    if (setpriority(PRIO_PROCESS, 0, priority) == -1) {
        fprintf(stderr, "Ошибка setpriority: не удается изменить значение\n");
        exit(EXIT_FAILURE);
    }

    // Имитация работы
    for (int i = 0; i < 10; i++) {
        // Создаем цикл for, что не будет оптимизирован компилятором
        volatile int counter = 0;
        for (size_t j = 0; j < 1000000000; j++) {
            counter++;
        }

        printf("prog2: PPID=[%d], PID=[%d], policy=[%s], priority=[%d]\n", getppid(), getpid(),
               get_policy_name(sched_getscheduler(0)), getpriority(PRIO_PROCESS, 0));
    }

    return 0;
}