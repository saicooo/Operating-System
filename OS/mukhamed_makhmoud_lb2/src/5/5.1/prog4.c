/*
 * ======================================================================
 * Лабораторная работа 2, задание 5.1 (планирование процессов)
 * ======================================================================
 *
 * ЗАДАЧА:
 * Определение политики планирования и приоритета, установленных по
 * умолчанию, для процессов, запускаемых пользователем из shell. Анализ
 * очередности исполнения процессов при различных приоритетах и политиках.
 *
 * ЧТО ДЕЛАЕТ ПРОГРАММА:
 * Программа prog4 является тестовой программой, которая выводит
 * информацию о себе. Используется для анализа очередности
 * исполнения процессов при их одновременном запуске с разными приоритетами
 * и политиками планирования. Выводит PID, PPID и текущую политику планирования.
 *
 * КОМПИЛЯЦИЯ И ЗАПУСК:
 * $ gcc prog4.c -o prog4
 * $ ./prog4
 * $ nice -n -10 ./prog4 # запуск с максимально повышенным приоритетом
 * $ taskset -c 0 nice -n -10 ./prog4 # с привязкой к ядру и повышенным приоритетом
 *
 * РЕЗУЛЬТАТЫ И ВЫВОДЫ:
 * - При запуске с наивысшим приоритетом (nice=-10) получает максимальное
 *   количество процессорного времени по сравнению со всеми другими процессами.
 * - Эксперимент наглядно демонстрирует, что процессы с наименьшим значением nice
 *   имеют наивысший приоритет при планировании в Linux.
 * - Подтверждает иерархию приоритетов в SCHED_OTHER: процессы с nice=-10
 *   имеют преимущество над всеми другими, включая процессы с nice=-5.
 * - Показывает, что даже в пределах одной политики планирования (SCHED_OTHER)
 *   существует строгая градация процессорного времени в зависимости от установленного
 *   nice значения.
 */

#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/resource.h>
#include <unistd.h>

// Функция для получения строкового представления политики планирования
char *get_policy_name(int policy) {
    char *policy_name;

    switch (policy) {
        case SCHED_FIFO:
            policy_name = "SCHED_FIFO";
            break;
        case SCHED_RR:
            policy_name = "SCHED_RR";
            break;
        case SCHED_OTHER:
            policy_name = "SCHED_OTHER";
            break;
        default:
            policy_name = "UNKNOWN";
            break;
    }

    return policy_name;
}

int main(int argc, char *argv[]) {

    if (argc < 2) {
        fprintf(stderr, "Ошибка argc: необходимо задать приоритет\n");
        exit(EXIT_FAILURE);
    }

    int priority = atoi(argv[1]);

    if (setpriority(PRIO_PROCESS, 0, priority) == -1) {
        fprintf(stderr, "Ошибка setpriority: не удается изменить значение\n");
        exit(EXIT_FAILURE);
    }

    // Имитация работы
    for (int i = 0; i < 10; i++) {
        // Создаем цикл for, что не будет оптимизирован компилятором
        volatile int counter = 0;
        for (size_t j = 0; j < 1000000000; j++) {
            counter++;
        }

        printf("prog4: PPID=[%d], PID=[%d], policy=[%s], priority=[%d]\n", getppid(), getpid(),
               get_policy_name(sched_getscheduler(0)), getpriority(PRIO_PROCESS, 0));
    }

    return 0;
}