#!/bin/bash
# =========================== НАЗНАЧЕНИЕ ===========================
# Исследование наследования различных атрибутов процесса при использовании
# системного вызова clone().
#
# 1. Тест 6.4.1: Наследование файловых дескрипторов через clone().
#    Родительский процесс открывает файл, записывает в него данные, затем
#    создает потомка с помощью clone(). Потомок продолжает запись в тот же
#    файл, после чего родитель завершает запись.
#
# 2. Тест 6.4.2: Наследование политики планирования через clone().
#    Родительский процесс устанавливает политику планирования SCHED_FIFO
#    с приоритетом 50, затем создает потомка через clone(). Потомок выводит
#    свою политику планирования и приоритет для проверки наследования.
#
# 3. Тест 6.4.3: Наследование сигналов через clone().
#    Родительский процесс устанавливает обработчики и диспозиции для
#    различных сигналов, затем создает потомка через clone(). Потомок
#    проверяет обработчики сигналов и демонстрирует их наследование
#    через получение сигнала от родителя.
#
# Результаты экспериментов показывают, что clone() сохраняет то же поведение
# наследования, что и fork(), для файловых дескрипторов, политик планирования
# и обработчиков сигналов, когда используется с соответствующими флагами.
# ==================================================================
# 
# ============================ КОМАНДЫ =============================
# Скрипт выполняет следующие действия:
# 1. Компилирует исходный файл prog.c, создавая исполняемый файл prog.
# 2. Запускает программу prog, которая выполняет все три теста:
#    - Тест 6.4.1: Проверка наследования файловых дескрипторов через clone().
#    - Тест 6.4.2: Проверка наследования политики планирования через clone().
#    - Тест 6.4.3: Проверка наследования обработчиков сигналов через clone().
# 3. Программа показывает результаты каждого теста, демонстрируя как
#    clone() наследует различные атрибуты процесса.
# 4. Очищает скомпилированные файлы после завершения работы.
#
# Выводы:
# - При использовании clone(), файловые дескрипторы полностью наследуются
#   дочерним процессом, что позволяет потомку работать с теми же открытыми
#   файлами, что и родитель.
# - Политика планирования и приоритет (SCHED_FIFO с приоритетом 50) также
#   наследуются потомком, созданным через clone().
# - Обработчики сигналов и их диспозиции наследуются через clone(), включая
#   как пользовательские обработчики (для SIGUSR1 и SIGTERM), так и
#   игнорирование сигналов (для SIGINT и SIGHUP).
# ==================================================================
# 

DIRECTORY="6/6.4"

SRC_FILES=("prog.c")
EXEC=("prog")

compilate_files() {
    local -n src_files=$1
    local -n obj_files=$2

    local count=${#src_files[@]}
    for ((i=0; i<"$count"; i++)); do
        gcc "${src_files[$i]}" -o "${obj_files[$i]}"
    done
}

cd "$DIRECTORY"

compilate_files SRC_FILES EXEC

./"${EXEC[${#EXEC[@]}-1]}" &

wait

rm "${EXEC[@]}"