/*
 * ======================================================================
 * Лабораторная работа 2, задание 6.1 (наследование файловых дескрипторов)
 * ======================================================================
 *
 * ЗАДАЧА:
 * Исследование наследования файловых дескрипторов на этапах fork() и exec().
 * Проведение экспериментов с родителем и потомками по доступу к одним и тем же
 * файлам, открытым родителем.
 *
 * ЧТО ДЕЛАЕТ ПРОГРАММА:
 * Программа выполняет часть теста 6.1.2: exec().
 * Потомок, созданный через fork(), выполняет exec() для запуска этой программы.
 * Программа продолжает запись в файл, открытый родительским процессом, используя
 * унаследованный файловый дескриптор.
 *
 * КОМПИЛЯЦИЯ И ЗАПУСК:
 * $ gcc son.c -o son
 *
 * РЕЗУЛЬТАТЫ И ВЫВОДЫ:
 * - Файловые дескрипторы сохраняются после exec(), если они не были закрыты или
 *   переопределены, что позволяет новой программе продолжать запись в файл.
 */

#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main() {
    const char *msg = "Потомок записал через exec\n";
    
    // Пишем сообщение в файловый дескриптор 3, который был унаследован от родителя
    // Дескриптор 3 был открыт в родительском процессе и сохранился после exec()
    if (write(3, msg, strlen(msg)) < 0) {
        // Обработка ошибки записи
        fprintf(stderr, "Ошибка write: запись в exec-потомке\n");
        exit(EXIT_FAILURE);
    }
    
    // Закрываем файловый дескриптор после окончания работы с ним
    close(3);
    
    return 0;
}