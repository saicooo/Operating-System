/*
 * ======================================================================
 * Лабораторная работа 2, задание 6.1 (наследование файловых дескрипторов)
 * ======================================================================
 *
 * ЗАДАЧА:
 * Исследование наследования файловых дескрипторов на этапах fork() и exec().
 * Проведение экспериментов с родителем и потомками по доступу к одним и тем же
 * файлам, открытым родителем.
 *
 * ЧТО ДЕЛАЕТ ПРОГРАММА:
 * Программа выполняет два теста:
 * 1. Тест 6.1.1: fork() - родительский процесс открывает файл, записывает в него
 *    данные, затем создает потомка через fork(). Потомок продолжает запись в тот
 *    же файл. После этого родитель завершает запись.
 * 2. Тест 6.1.2: exec() - родительский процесс открывает файл, записывает в него
 *    данные, затем создает потомка через fork(), который выполняет exec() для
 *    запуска другой программы. Эта программа продолжает запись в тот же файл.
 *
 * КОМПИЛЯЦИЯ И ЗАПУСК:
 * $ gcc father.c -o father
 * $ ./father
 *
 * РЕЗУЛЬТАТЫ И ВЫВОДЫ:
 * - Файловые дескрипторы наследуются при fork(), что позволяет родителю и потомку
 *   записывать в один и тот же файл.
 * - Файловые дескрипторы сохраняются после exec(), если они не были закрыты или
 *   переопределены, что позволяет новой программе продолжать запись в файл.
 */

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

// Функция для тестирования наследования файловых дескрипторов через fork()
void test_fork() {
    printf("\n===== Тест 6.1.1: fork() =====\n");
    
    // Открываем файл для записи (создаем новый или очищаем существующий)
    int fd = open("6.1_fork.log", O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (fd < 0) {
        fprintf(stderr, "Ошибка open: не удалось создать файл\n");
        exit(EXIT_FAILURE);
    }

    // Родитель записывает в файл до создания потомка
    const char *parent_msg = "Родитель записал до fork\n";
    if (write(fd, parent_msg, strlen(parent_msg)) < 0) {
        fprintf(stderr, "Ошибка write: запись родителя до fork\n");
        exit(EXIT_FAILURE);
    }

    // Создаем дочерний процесс
    pid_t pid = fork();
    if (pid < 0) {
        fprintf(stderr, "Ошибка fork: невозможно создать потомка\n");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Код потомка - записываем сообщение в наследованный файловый дескриптор
        const char *child_msg = "Потомок записал через fork\n";
        if (write(fd, child_msg, strlen(child_msg)) < 0) {
            fprintf(stderr, "Ошибка write: запись потомка\n");
            exit(EXIT_FAILURE);
        }
        close(fd);  // Закрываем дескриптор в потомке
        exit(EXIT_SUCCESS);  // Завершаем потомка
    } else {
        // Код родителя - ждем завершения потомка и продолжаем запись
        wait(NULL);  // Ожидаем завершения потомка
        const char *parent_msg2 = "Родитель записал после fork\n";
        if (write(fd, parent_msg2, strlen(parent_msg2)) < 0) {
            fprintf(stderr, "Ошибка write: запись родителя после fork\n");
            exit(EXIT_FAILURE);
        }
        close(fd);  // Закрываем дескриптор в родителе
    }
    printf("Файл 6.1_fork.log создан\n");
    
    // Выводим содержимое файла в консоль
    system("echo '\n--- Содержимое файла 6.1_fork.log ---\n' && cat 6.1_fork.log");
}

// Функция для тестирования наследования файловых дескрипторов через exec()
void test_exec() {
    printf("\n===== Тест 6.1.2: exec() =====\n");
    
    // Открываем файл для записи (создаем новый или очищаем существующий)
    int fd = open("6.1_exec.log", O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (fd < 0) {
        fprintf(stderr, "Ошибка open: не удалось создать файл\n");
        exit(EXIT_FAILURE);
    }

    // Родитель записывает в файл до создания потомка
    const char *parent_msg = "Родитель записал до exec\n";
    if (write(fd, parent_msg, strlen(parent_msg)) < 0) {
        fprintf(stderr, "Ошибка write: запись родителя до exec\n");
        exit(EXIT_FAILURE);
    }

    // Создаем дочерний процесс
    pid_t pid = fork();
    if (pid < 0) {
        fprintf(stderr, "Ошибка fork: невозможно создать потомка\n");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Код потомка - дублируем дескриптор на fd=3 и запускаем другую программу
        if (dup2(fd, 3) < 0) {
            fprintf(stderr, "Ошибка dup2: невозможно перенаправить дескриптор\n");
            exit(EXIT_FAILURE);
        }
        // Заменяем образ процесса на son
        execl("./son", "son", NULL);
        fprintf(stderr, "Ошибка execl: не удалось выполнить программу\n");
        exit(EXIT_FAILURE);
    } else {
        // Код родителя - ждем завершения потомка
        wait(NULL);  // Ожидаем завершения потомка
        close(fd);   // Закрываем дескриптор
    }
    printf("Файл 6.1_exec.log создан\n");
    
    // Выводим содержимое файла в консоль
    system("echo '\n--- Содержимое файла 6.1_fork.log ---\n' && cat 6.1_fork.log");
}

// Главная функция программы
int main() {
    test_fork();  // Запускаем тест наследования через fork()
    test_exec();  // Запускаем тест наследования через exec()
    return 0;
}