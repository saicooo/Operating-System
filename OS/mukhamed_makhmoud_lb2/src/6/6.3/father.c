/*
 * ======================================================================
 * Лабораторная работа 2, задание 6.3 (диспозиции и наследование сигналов)
 * ======================================================================
 *
 * ЗАДАЧА:
 * Исследование диспозиции и наследования сигналов при системных вызовах
 * fork() и exec(). Проверка сохранения обработчиков и действий для сигналов
 * при создании и замене процессов.
 *
 * ЧТО ДЕЛАЕТ ПРОГРАММА:
 * Программа выполняет два теста:
 * 1. Тест 6.3.1: fork() - родительский процесс устанавливает пользовательский
 *    обработчик для сигнала SIGUSR1 (10), создает потомка через fork() и
 *    отправляет сигнал потомку, демонстрируя наследование обработчика.
 * 2. Тест 6.3.2: exec() - родительский процесс устанавливает различные
 *    диспозиции для сигналов SIGUSR1 (10) и SIGUSR2 (12), затем создает
 *    потомка через fork(), который выполняет exec() для запуска другой
 *    программы. Новая программа проверяет, сохранились ли диспозиции
 *    сигналов после exec().
 *
 * КОМПИЛЯЦИЯ И ЗАПУСК:
 * $ gcc father.c -o father
 * $ ./father
 *
 * РЕЗУЛЬТАТЫ И ВЫВОДЫ:
 * - При использовании fork(), обработчики сигналов полностью наследуются
 *   дочерним процессом, что подтверждается вызовом обработчика SIGUSR1
 *   в дочернем процессе.
 * - При использовании exec(), общие диспозиции сигналов (игнорирование
 *   или обработка по умолчанию) сохраняются, но пользовательские
 *   обработчики сбрасываются до состояния по умолчанию.
 * - Это демонстрирует принципиальное различие в наследовании сигналов
 *   между fork() (полное наследование) и exec() (сохраняется только
 *   информация о действиях, но не обработчики).
 */

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

// Функция-обработчик сигнала - вызывается при получении сигнала SIGUSR1
void handler(int sig) {
    printf("Обработчик: PPID=[%d], PID=[%d], signal=[%d]\n", getppid(), getpid(), sig);
}

// Функция для тестирования наследования обработчиков сигналов при fork()
void test_fork() {
    printf("\n===== Тест 6.3.1: fork() =====\n");

    // Устанавливаем пользовательский обработчик для сигнала SIGUSR1
    if (signal(SIGUSR1, handler) == SIG_ERR) {
        fprintf(stderr, "Ошибка signal: SIGUSR1\n");
        exit(EXIT_FAILURE);
    }

    // Устанавливаем игнорирование для сигнала SIGUSR2
    if (signal(SIGUSR2, SIG_IGN) == SIG_ERR) {
        fprintf(stderr, "Ошибка signal: SIGUSR2\n");
        exit(EXIT_FAILURE);
    }

    // Создаем новый процесс с помощью fork()
    pid_t pid = fork();
    if (pid < 0) {
        // Обработка ошибки при создании нового процесса
        fprintf(stderr, "Ошибка fork: невозможно создать потомка\n");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Код, выполняемый дочерним процессом
        printf("son: PPID=[%d], PID=[%d]\n", getpid(), getppid());
        // Отправляем сигналы самому себе для проверки обработчиков
        kill(getpid(), SIGUSR1);  // Вызовет пользовательский обработчик
        kill(getpid(), SIGUSR2);  // Будет проигнорирован
        sleep(1);  // Пауза для обработки сигналов
        exit(EXIT_SUCCESS);
    } else {
        // Код, выполняемый родительским процессом
        printf("father: PPID=[%d], PID=[%d]\n", getppid(), getpid());
        // Ждем завершения дочернего процесса
        wait(NULL);
    }
}

// Функция для тестирования сохранения диспозиций сигналов при exec()
void test_exec() {
    printf("\n===== Тест 6.3.2: exec() =====\n");

    // Устанавливаем пользовательский обработчик для сигнала SIGUSR1
    if (signal(SIGUSR1, handler) == SIG_ERR) {
        fprintf(stderr, "Ошибка signal: SIGUSR1\n");
        exit(EXIT_FAILURE);
    }

    // Устанавливаем игнорирование для сигнала SIGUSR2
    if (signal(SIGUSR2, SIG_IGN) == SIG_ERR) {
        fprintf(stderr, "Ошибка signal: SIGUSR2\n");
        exit(EXIT_FAILURE);
    }

    // Создаем новый процесс с помощью fork()
    pid_t pid = fork();
    if (pid < 0) {
        // Обработка ошибки при создании нового процесса
        fprintf(stderr, "Ошибка fork: невозможно создать потомка\n");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Код, выполняемый дочерним процессом
        // Заменяем текущий процесс новой программой "./son"
        // После exec() диспозиция SIG_IGN сохранится, а пользовательский обработчик сбросится
        execl("./son", "son", NULL);
        
        // Этот код выполнится только при ошибке execl
        fprintf(stderr, "Ошибка execl: не удалось выполнить программу\n");
        exit(EXIT_FAILURE);
    } else {
        // Код, выполняемый родительским процессом
        printf("father: PPID=[%d], PID=[%d]\n", getppid(), getpid());
        // Ждем завершения дочернего процесса
        wait(NULL);
    }
}

// Главная функция программы
int main() {
    test_fork();  // Выполнение теста наследования сигналов при fork()
    test_exec();  // Выполнение теста сохранения диспозиций сигналов при exec()
    return 0;
}