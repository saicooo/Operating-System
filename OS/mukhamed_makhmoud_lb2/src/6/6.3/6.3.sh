#!/bin/bash
# =========================== НАЗНАЧЕНИЕ ===========================
# Исследование диспозиции и наследования сигналов при использовании
# системных вызовов fork() и exec().
#
# 1. Тест 6.3.1: Наследование обработчиков сигналов при fork().
#    Родительский процесс устанавливает пользовательский обработчик
#    для сигнала SIGUSR1 (10), затем создает потомка через fork().
#    Затем родитель посылает сигнал SIGUSR1 потомку для проверки
#    наследования обработчика.
#
# 2. Тест 6.3.2: Наследование диспозиций сигналов при exec().
#    Родительский процесс устанавливает различную обработку для
#    сигналов SIGUSR1 (10) и SIGUSR2 (12), затем создает потомка
#    через fork(), который выполняет exec(). Новая программа
#    проверяет, сохранились ли диспозиции сигналов после exec().
#
# Результаты экспериментов демонстрируют, что диспозиции сигналов
# наследуются при fork() и сохраняются после exec(), но пользовательские
# обработчики сбрасываются до состояния по умолчанию после exec().
# ==================================================================
# 
# ============================ КОМАНДЫ =============================
# Скрипт выполняет следующие действия:
# 1. Компилирует исходные файлы father.c и son.c, создавая исполняемые
#    файлы father и son.
# 2. Запускает программу father, которая выполняет оба теста:
#    - Тест 6.3.1: fork() - проверка наследования обработчиков сигналов
#      при создании процесса через fork().
#    - Тест 6.3.2: exec() - проверка сохранения диспозиций сигналов
#      после запуска новой программы через exec().
# 3. Ожидает завершения всех процессов.
# 4. Удаляет скомпилированные исполняемые файлы после завершения работы.
#
# Выводы:
# - При использовании fork(), обработчики сигналов полностью наследуются
#   дочерним процессом от родительского, как показывает вызов обработчика
#   сигнала SIGUSR1 в дочернем процессе.
# - При использовании exec(), диспозиции сигналов (игнорирование или обработка
#   по умолчанию) сохраняются, но пользовательские обработчики сбрасываются 
#   до действия по умолчанию.
# - Это демонстрирует, что fork() полностью копирует модель обработки сигналов,
#   а exec() сохраняет только диспозиции, но не указатели на функции-обработчики,
#   так как они указывают на код, который заменяется при exec().
# ==================================================================
# 

DIRECTORY="6/6.3"

SRC_FILES=("son.c" "father.c")
EXEC=("son" "father")

compilate_files() {
    local -n src_files=$1
    local -n obj_files=$2

    local count=${#src_files[@]}
    for ((i=0; i<"$count"; i++)); do
        gcc "${src_files[$i]}" -o "${obj_files[$i]}"
    done
}

cd "$DIRECTORY"

compilate_files SRC_FILES EXEC

./"${EXEC[${#EXEC[@]}-1]}" &

wait

rm "${EXEC[@]}"