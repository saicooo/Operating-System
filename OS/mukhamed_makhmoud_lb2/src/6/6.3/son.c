/*
 * ======================================================================
 * Лабораторная работа 2, задание 6.3 (диспозиции и наследование сигналов)
 * ======================================================================
 *
 * ЗАДАЧА:
 * Исследование сохранения диспозиций сигналов после выполнения exec().
 * Проверка, какие аспекты обработки сигналов сохраняются, а какие теряются
 * при замене образа процесса.
 *
 * ЧТО ДЕЛАЕТ ПРОГРАММА:
 * Программа выполняет часть теста 6.3.2: exec().
 * Запускается через exec() из дочернего процесса, созданного в father.c.
 * Проверяет диспозиции сигналов SIGUSR1 (10) и SIGUSR2 (12), которые были
 * установлены в родительском процессе до exec(). Программа выводит состояние
 * этих сигналов, демонстрируя, что диспозиции сохраняются (игнорирование
 * сигнала SIGUSR2), но пользовательские обработчики (для SIGUSR1)
 * сбрасываются до действия по умолчанию.
 *
 * КОМПИЛЯЦИЯ И ЗАПУСК:
 * $ gcc son.c -o son
 *
 * РЕЗУЛЬТАТЫ И ВЫВОДЫ:
 * - Сигнал SIGUSR1, для которого в родительском процессе был установлен
 *   пользовательский обработчик, после exec() обрабатывается по умолчанию.
 * - Сигнал SIGUSR2, который был установлен на игнорирование в родительском
 *   процессе, продолжает игнорироваться после exec().
 * - Это демонстрирует, что exec() сохраняет общие диспозиции сигналов (SIG_IGN),
 *   но сбрасывает пользовательские обработчики до состояния по умолчанию.
 */

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void check_signal(int sig) {
    void (*handler)(int) = signal(sig, SIG_DFL);
    if (handler == SIG_ERR) {
        fprintf(stderr, "Ошибка проверки сигнала %d\n", sig);
        exit(EXIT_FAILURE);
    }

    // Выводим сообщение о том, какой тип обработчика установлен для сигнала
    if (handler == SIG_DFL) {
        printf("Сигнал %d: по умолчанию\n", sig);
    } else if (handler == SIG_IGN) {
        printf("Сигнал %d: игнорируется\n", sig);
    } else {
        printf("Сигнал %d: пользовательский обработчик\n", sig);
    }
}

// Главная функция программы
int main() {
    // Выводим информацию о процессе
    printf("exec-потомок: PPID=[%d], PID=[%d]\n\n", getppid(), getpid());
    
    // Проверяем, какие диспозиции установлены для сигналов SIGUSR1 и SIGUSR2
    check_signal(SIGUSR1);  // Проверяем сигнал SIGUSR1 (ожидается SIG_DFL после exec)
    check_signal(SIGUSR2);  // Проверяем сигнал SIGUSR2 (ожидается SIG_IGN после exec)

    // Отправляем сигнал SIGUSR1 самому себе
    // Ожидается, что действие будет по умолчанию
    if (kill(getpid(), SIGUSR1) != 0) {
        fprintf(stderr, "Ошибка отправки SIGUSR1\n");
        exit(EXIT_FAILURE);
    }

    // Отправляем сигнал SIGUSR2 самому себе
    // Ожидается, что сигнал будет проигнорирован
    if (kill(getpid(), SIGUSR2) != 0) {
        fprintf(stderr, "Ошибка отправки SIGUSR2\n");
        exit(EXIT_FAILURE);
    }

    return 0;
}