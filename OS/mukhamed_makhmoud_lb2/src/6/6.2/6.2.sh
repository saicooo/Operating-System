#!/bin/bash
# =========================== НАЗНАЧЕНИЕ ===========================
# Исследование наследования приоритетов и политики планирования при 
# использовании системных вызовов fork() и exec().
#
# 1. Тест 6.2.1: Наследование приоритетов и политики планирования при fork().
#    Родительский процесс устанавливает политику SCHED_RR с приоритетом 50
#    и значением nice 10, затем создает потомка через fork(). 
#    Проверяется, наследуются ли эти параметры потомком.
#
# 2. Тест 6.2.2: Наследование приоритетов и политики планирования при exec().
#    Родительский процесс устанавливает политику SCHED_FIFO с приоритетом 50
#    и значением nice 5, затем создает потомка через fork(), который выполняет
#    exec() для запуска другой программы. Проверяется, сохраняются ли
#    эти параметры после exec().
#
# Результаты экспериментов демонстрируют, что приоритеты и политики планирования
# наследуются как при fork(), так и сохраняются после exec().
# ==================================================================
# 
# ============================ КОМАНДЫ =============================
# Скрипт выполняет следующие действия:
# 1. Компилирует исходные файлы father.c и son.c, создавая исполняемые файлы
#    father и son.
# 2. Запускает программу father, которая выполняет оба теста:
#    - Тест 6.2.1: fork() - проверка наследования приоритетов и политики
#      планирования при создании процесса через fork().
#    - Тест 6.2.2: exec() - проверка сохранения приоритетов и политики
#      планирования после запуска новой программы через exec().
# 3. Ожидает завершения всех процессов.
# 4. Удаляет скомпилированные исполняемые файлы после завершения работы.
#
# Выводы:
# - При использовании fork(), приоритет и политика планирования полностью
#   наследуются дочерним процессом от родительского (SCHED_RR, приоритет 50).
# - При использовании exec(), приоритет и политика планирования сохраняются
#   (SCHED_FIFO, приоритет 50) даже после запуска новой программы.
# ==================================================================
# 

DIRECTORY="6/6.2"

SRC_FILES=("son.c" "father.c")
EXEC=("son" "father")

compilate_files() {
    local -n src_files=$1
    local -n obj_files=$2

    local count=${#src_files[@]}
    for ((i=0; i<"$count"; i++)); do
        gcc "${src_files[$i]}" -o "${obj_files[$i]}"
    done
}

cd "$DIRECTORY"

compilate_files SRC_FILES EXEC

./"${EXEC[${#EXEC[@]}-1]}" &

wait

rm "${EXEC[@]}"