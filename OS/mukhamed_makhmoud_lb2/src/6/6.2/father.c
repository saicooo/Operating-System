/*
 * ======================================================================
 * Лабораторная работа 2, задание 6.2 (наследование приоритетов и планирования)
 * ======================================================================
 *
 * ЗАДАЧА:
 * Исследование наследования приоритетов и политики планирования при fork() и exec().
 * Проведение экспериментов с родителем и потомками для подтверждения сохранения
 * параметров планирования при создании и замене процессов.
 *
 * ЧТО ДЕЛАЕТ ПРОГРАММА:
 * Программа выполняет два теста:
 * 1. Тест 6.2.1: fork() - родительский процесс устанавливает политику SCHED_RR
 *    с приоритетом 50, затем создает потомка через fork(). Оба процесса
 *    выводят свои параметры планирования, демонстрируя их наследование.
 * 2. Тест 6.2.2: exec() - родительский процесс устанавливает политику SCHED_FIFO
 *    с приоритетом 50, затем создает потомка через fork(), который
 *    выполняет exec() для запуска другой программы. Новая программа выводит
 *    свои параметры планирования, демонстрируя их сохранение после exec().
 *
 * КОМПИЛЯЦИЯ И ЗАПУСК:
 * $ gcc father.c -o father
 * $ ./father
 *
 * РЕЗУЛЬТАТЫ И ВЫВОДЫ:
 * - При использовании fork(), приоритет и политика планирования полностью
 *   наследуются дочерним процессом от родительского (SCHED_RR, приоритет 50).
 * - При использовании exec(), приоритет и политика планирования сохраняются
 *   (SCHED_FIFO, приоритет 50) даже после запуска новой программы.
 */

#include <errno.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <unistd.h>

// Функция для получения типа планирования в строковом виде
char *get_policy_name(int policy) {
    char *policy_name;

    // Определяем название политики планирования по её числовому идентификатору
    switch (policy) {
        case SCHED_FIFO:
            policy_name = "SCHED_FIFO";
            break;
        case SCHED_RR:
            policy_name = "SCHED_RR";
            break;
        case SCHED_OTHER:
            policy_name = "SCHED_OTHER";
            break;
        default:
            policy_name = "UNKNOWN";
            break;
    }

    return policy_name;
}

// Функция для вывода информации о параметрах планирования процесса
void print_scheduling_info(const char *name) {
    // Получаем текущую политику планирования для текущего процесса (0)
    int policy = sched_getscheduler(0);
    if (policy < 0) {
        fprintf(stderr, "Ошибка sched_getscheduler: невозможно получить политику планирования\n");
        exit(EXIT_FAILURE);
    }

    // Получаем дополнительные параметры планирования (приоритет)
    struct sched_param param;
    if (sched_getparam(0, &param) < 0) {
        fprintf(
            stderr,
            "Ошибка sched_getparam: невозможно получить дополнительные параметры планирования\n");
        exit(EXIT_FAILURE);
    }

    // Выводим информацию о процессе и его параметрах планирования
    printf("%s: PPID=[%d], PID=[%d], policy=[%s], priority=[%d]\n", name, getppid(), getpid(),
           get_policy_name(policy), param.sched_priority);
}

// Функция для тестирования наследования параметров планирования при fork()
void test_fork() {
    // Заголовок для первого теста - проверка наследования параметров при fork()
    printf("\n===== Тест 6.2.1: fork() =====\n");

    // Устанавливаем политику планирования SCHED_RR с приоритетом 50
    struct sched_param param = {.sched_priority = 50};
    if (sched_setscheduler(0, SCHED_RR, &param) < 0) {
        fprintf(stderr, "Ошибка sched_setscheduler: невозможно изменить политику планирования\n");
        exit(EXIT_FAILURE);
    }

    // Выводим информацию о параметрах планирования родительского процесса
    print_scheduling_info("Родитель (до fork)");

    // Создаем новый процесс с помощью fork()
    pid_t pid = fork();
    if (pid < 0) {
        // Обработка ошибки при создании нового процесса
        fprintf(stderr, "Ошибка fork: невозможно создать потомка\n");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Код, выполняемый потомком (дочерним процессом)
        print_scheduling_info("Потомок");
        // Завершаем дочерний процесс с кодом успешного выполнения
        exit(EXIT_SUCCESS);
    } else {
        // Код, выполняемый родителем
        // Ждем завершения дочернего процесса, чтобы избежать создания процесса-зомби
        wait(NULL);
    }
}

// Функция для тестирования сохранения параметров планирования при exec()
void test_exec() {
    // Заголовок для второго теста - проверка сохранения параметров при exec()
    printf("\n===== Тест 6.2.2: exec() =====\n");

    // Инициализация структуры с параметрами планировщика
    // Устанавливаем приоритет 50
    struct sched_param param = {.sched_priority = 50};
    
    // Устанавливаем политику планирования SCHED_FIFO (First-In-First-Out)
    // для текущего процесса (0) с заданными параметрами
    if (sched_setscheduler(0, SCHED_FIFO, &param) < 0) {
        // Обработка ошибки при невозможности установить политику планирования
        fprintf(stderr, "Ошибка sched_setscheduler: невозможно изменить политику планирования\n");
        exit(EXIT_FAILURE);
    }

    // Выводим информацию о параметрах планирования родительского процесса
    print_scheduling_info("Родитель (до exec)");

    // Создаем новый процесс с помощью fork()
    pid_t pid = fork();
    if (pid < 0) {
        // Обработка ошибки при создании нового процесса
        fprintf(stderr, "Ошибка fork: невозможно создать потомка\n");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Код, выполняемый дочерним процессом
        // Заменяем текущий процесс новой программой "./son"
        // При этом параметры планирования сохранятся
        execl("./son", "son", NULL);
        
        // Код ниже выполнится только при ошибке в execl
        fprintf(stderr, "Ошибка execl: не удалось выполнить программу\n");
        exit(EXIT_FAILURE);
    } else {
        // Код, выполняемый родителем
        // Ждем завершения дочернего процесса
        wait(NULL);
    }
}

// Главная функция программы
int main() {
    // Запускаем тесты для проверки наследования параметров планирования
    test_fork();  // Тест наследования при fork()
    test_exec();  // Тест сохранения при exec()
    return 0;
}