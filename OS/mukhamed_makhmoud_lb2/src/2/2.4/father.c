/*
 * ======================================================================
 * Лабораторная работа 2, задание 2.4 (родительский процесс)
 * ======================================================================
 *
 * ЗАДАЧА:
 * Демонстрация трех различных сценариев взаимодействия родительского
 * и дочернего процессов для изучения состояний процессов в Linux:
 * а) Нормальное завершение - родитель ожидает завершения потомка
 * б) Orphan процесс - родитель завершается раньше потомка
 * в) Zombie процесс - потомок завершается, но родитель не собирает его статус
 *
 * ЧТО ДЕЛАЕТ ПРОГРАММА:
 * В зависимости от переданного аргумента ('a', 'b' или 'c') демонстрирует
 * один из трех сценариев взаимодействия родительского и дочернего процессов.
 * Запускает дочерний процесс через execl, передавая ему соответствующий параметр.
 *
 * КОМПИЛЯЦИЯ И ЗАПУСК:
 * $ gcc father.c -o father
 * $ gcc son.c -o son
 * $ ./father a  # демонстрация нормального завершения
 * $ ./father b  # демонстрация orphan-процесса
 * $ ./father c  # демонстрация zombie-процесса
 *
 * РЕЗУЛЬТАТЫ И ВЫВОДЫ:
 * - Нормальное завершение: родитель ждет завершения потомка с помощью waitpid()
 * - Orphan процесс: потомок "осиротел", его новым родителем становится процесс уровня инициализации
 * системы
 * - Zombie процесс: потомок завершился, но его запись остается в таблице процессов
 *    (до тех пор, пока родитель не запросит код возврата потомка)
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

// Функция для создания процесса-потомка и запуска программы son с заданным аргументом (сценарием)
pid_t make_scenario(const char *scenario) {
    pid_t pid = fork(); // Клонируем родителя

    if (pid < 0) {
        fprintf(stderr, "Ошибка создания потомка для случая: [%s]", scenario);
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Запускаем потомка son
        execl("son", "son", scenario, NULL);
        fprintf(stderr, "Ошибка execl для случая: [%s]", scenario);
        exit(EXIT_FAILURE);
    }

    return pid;
}

int main(int argc, char *argv[]) {
    // Отключаем буферизацию
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);

    char cmd[256];
    sprintf(cmd, "\n--- Информация о father ---\nPID=[%d], PPID=[%d]\n\n", getpid(), getppid());
    printf("%s", cmd);

    char n = argv[1][0];
    switch (n) {
        // Ситуация (а): создание потомка, которого родитель ожидает
        case 'a':
            pid_t pid_a = make_scenario("a");
            waitpid(pid_a, NULL, 0);
            break;

        // Ситуация (б): создание потомка, который станет orphan
        case 'b':
            make_scenario("b");
            break;

        // Ситуация (в): создание потомка, который завершится и станет зомби
        case 'c':
            pid_t pid_c = make_scenario("c");

            // Задержка, чтобы сын успел завершиться полностью
            sleep(2);

            // Вывод информации о процессах от родительского процесса
            sprintf(cmd, "echo '\n--- Вывод ps от процесса-отца (PID=%d) ---' && ps -l",
                    getpid());
            system(cmd);

            // Завершаем процесс-зомби
            waitpid(pid_c, NULL, 0);
            break;

        default:
            break;
    }

    return 0;
}