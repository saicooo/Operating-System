/*
 * ======================================================================
 * Лабораторная работа 2, задание 2.2 (родительский процесс)
 * ======================================================================
 *
 * ЗАДАЧА:
 * Создание программ родителя и потомка с размещением в разных файлах.
 * Фиксация состояния таблицы процессов с помощью системных вызовов.
 * Демонстрация работы процессов в обычном и фоновом режимах.
 *
 * ЧТО ДЕЛАЕТ ПРОГРАММА:
 * 1. Выводит свой PID и PPID
 * 2. Создает дочерний процесс с помощью fork()
 * 3. Заменяет код дочернего процесса на son.c через execl()
 * 4. Ожидает завершения дочернего процесса (waitpid)
 * 5. Выводит таблицу процессов с помощью команды ps -l
 * 6. Завершается
 *
 * КОМПИЛЯЦИЯ И ЗАПУСК:
 * $ gcc father.c -o father
 * $ gcc son.c -o son
 * $ ./father        # обычный режим запуска
 * $ ./father &      # фоновый режим запуска
 *
 * РЕЗУЛЬТАТЫ И ВЫВОДЫ:
 * - При обычном запуске родительским процессом будет shell терминала (или bash-скрипт)
 * - При фоновом запуске в таблице процессов можно увидеть другие взаимосвязи
 * - Команда ps -l показывает подробную информацию о процессах:
 *   F - флаги, S - состояние, UID/PID/PPID - идентификаторы,
 *   C - использование CPU, PRI - приоритет, и т.д.
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
    // Отключаем буферизацию
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);

    char cmd[256];
    sprintf(cmd, "\n--- Информация о father ---\nPID=[%d], PPID=[%d]\n\n", getpid(), getppid());
    printf("%s", cmd);

    pid_t pid = fork();

    if (pid < 0) {
        fprintf(stderr, "Ошибка создания потомка\n");
        exit(1);
    }

    if (pid == 0) {
        // Запуск потомка son
        execl("./son", "son", NULL);
    }

    waitpid(pid, NULL, 0);

    // Добавляем разделитель и метку процесса
    sprintf(cmd, "echo '\n--- Вывод ps от процесса-родителя (PID=%d) ---' && ps -l", getpid());
    system(cmd);
    printf("Родитель завершил работу\n");

    return 0;
}